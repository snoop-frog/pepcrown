<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pepodin Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root {
      --primary: #6200ea;
      --primary-light: #7c4dff;
      --dark: #121212;
      --dark-surface: #1e1e1e;
      --text: #ffffff;
      --text-secondary: #b0b0b0;
    }
    
    body, html {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--dark);
      color: var(--text);
      height: 100%;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    h1 {
      margin: 0;
      background: linear-gradient(45deg, var(--primary), var(--primary-light));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-size: 2rem;
    }
    
    .editor-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      flex: 1;
    }
    
    .editor-area {
      flex: 1;
      min-width: 300px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow-x: auto;
      max-width: 100%;
    }
    
    .controls {
      flex: 0 0 280px;
      background: var(--dark-surface);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    
    .editor {
      position: relative;
      margin: auto;
      display: inline-block;
      background-image: linear-gradient(45deg, #333 25%, transparent 25%), 
                        linear-gradient(-45deg, #333 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #333 75%), 
                        linear-gradient(-45deg, transparent 75%, #333 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      max-width: 100%;
      max-height: 70vh;
      cursor: pointer; /* Show pointer cursor on the editor area */
    }
    
    .editor img.base {
      display: block;
      max-width: 100%;
      max-height: 70vh;
      height: auto;
      object-fit: contain;
    }
    
    .overlay {
      position: absolute;
      top: 50px;
      left: 50px;
      width: 128px;
      height: 128px;
      transform-origin: center center;
      cursor: move;
      user-select: none;
      filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
    }
    
    .overlay.follow-cursor {
      pointer-events: none; /* Allow clicks to pass through when following cursor */
      cursor: none;
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    .control-group h3 {
      margin: 0 0 10px 0;
      font-size: 1rem;
      color: var(--primary-light);
      border-bottom: 1px solid #444;
      padding-bottom: 5px;
    }
    
    label {
      display: block;
      margin: 8px 0 4px;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }
    
    input[type="range"] {
      width: 100%;
      margin: 5px 0;
      -webkit-appearance: none;
      height: 5px;
      background: #444;
      border-radius: 5px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
    }
    
    .file-input {
      width: 100%;
      position: relative;
      margin: 10px 0;
    }
    
    .file-input label {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--primary);
      color: white;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
      text-align: center;
    }
    
    .file-input:hover label {
      background: var(--primary-light);
    }
    
    .file-input input[type="file"] {
      position: absolute;
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      z-index: -1;
    }
    
    button {
      width: 100%;
      background: var(--primary);
      color: white;
      border: none;
      padding: 12px;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.3s, transform 0.2s;
      margin: 5px 0;
    }
    
    button:hover {
      background: var(--primary-light);
      transform: translateY(-2px);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    .overlay-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }
    
    .overlay-option {
      width: 60px;
      height: 60px;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .overlay-option:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .overlay-option.active {
      border-color: var(--primary);
    }
    
    .overlay-option img {
      max-width: 80%;
      max-height: 80%;
    }
    
    .status-message {
      text-align: center;
      margin: 10px 0;
      padding: 8px;
      border-radius: 4px;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    .status-message.success {
      background: rgba(76, 175, 80, 0.2);
      color: #81c784;
      opacity: 1;
    }
    
    .feature-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    .feature-controls button {
      flex: 1;
      padding: 8px;
    }
    
    footer {
      text-align: center;
      margin-top: 20px;
      font-size: 0.8rem;
      color: var(--text-secondary);
      padding: 10px;
    }

    /* Toggle button for placement mode */
    .placement-mode-toggle {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
      margin-right: 10px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #444;
      transition: .4s;
      border-radius: 24px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: var(--primary);
    }
    
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .editor-container {
        flex-direction: column;
      }
      .controls {
        width: 100%;
        flex: none;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <header>
    <h1>Pepodin Editor</h1>
  </header>
  
  <div class="editor-container">
    <div class="editor-area">
      <div class="editor" id="editor">
        <img id="baseImage" class="base" src="" alt="Base image">
        <img id="overlay" class="overlay" src="https://i.imgur.com/a5srfjG.png" alt="Overlay image">
      </div>
      <div id="statusMessage" class="status-message"></div>
    </div>
    
    <div class="controls">
      <div class="control-group">
        <h3>Images</h3>
        <div class="file-input">
          <label for="upload">Upload Base Image</label>
          <input type="file" id="upload" accept="image/*">
        </div>
        
        <div class="file-input">
          <label for="uploadOverlay">Upload Custom Overlay</label>
          <input type="file" id="uploadOverlay" accept="image/*">
        </div>
        
        <label>Choose Overlay:</label>
        <div class="overlay-picker" id="overlayPicker">
          <div class="overlay-option active" data-src="https://i.imgur.com/a5srfjG.png">
            <img src="https://i.imgur.com/a5srfjG.png" alt="Crown">
          </div>
          <div class="overlay-option" data-src="https://i.imgur.com/a5srfjG.png">
            <img src="https://i.imgur.com/a5srfjG.png" alt="Crown 2">
          </div>
          <div class="overlay-option" data-src="https://i.imgur.com/a5srfjG.png">
            <img src="https://i.imgur.com/a5srfjG.png" alt="Crown 3">
          </div>
        </div>
        
        <div class="placement-mode-toggle">
          <label class="toggle-switch">
            <input type="checkbox" id="placementModeToggle">
            <span class="slider"></span>
          </label>
          <span>Click-to-Place Mode</span>
        </div>
      </div>
      
      <div class="control-group">
        <h3>Adjustments</h3>
        <label>Size: <span id="scaleValue">100%</span></label>
        <input type="range" id="scaleSlider" min="0.05" max="3" step="0.01" value="1">
        
        <label>Rotation: <span id="rotateValue">0°</span></label>
        <input type="range" id="rotateSlider" min="-180" max="180" step="1" value="0">
        
        <label>Opacity: <span id="opacityValue">100%</span></label>
        <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="1">
      </div>
      
      <div class="control-group">
        <h3>Actions</h3>
        <button onclick="resetOverlay()">Reset Position</button>
        <button onclick="centerOverlay()">Center Overlay</button>
        <div class="feature-controls">
          <button onclick="flipHorizontal()">Flip H</button>
          <button onclick="flipVertical()">Flip V</button>
        </div>
        <button onclick="saveImage()">Save Image</button>
      </div>
    </div>
  </div>
  
  <footer>
    Pepodin Editor
  </footer>
</div>

<script>
  // Elements
  const overlay = document.getElementById('overlay');
  const baseImage = document.getElementById('baseImage');
  const editor = document.getElementById('editor');
  const statusMessage = document.getElementById('statusMessage');
  const placementModeToggle = document.getElementById('placementModeToggle');
  
  // State variables
  let isDragging = false;
  let offsetX = 0, offsetY = 0;
  let isFlippedH = false;
  let isFlippedV = false;
  let isPlacementMode = false;
  let isFollowingCursor = false;
  
  // Default placeholder image
  window.addEventListener('load', () => {
    if (!baseImage.src || baseImage.src === window.location.href) {
      baseImage.src = 'https://i.imgur.com/KwDw0s9.jpg'; // Placeholder image
      setTimeout(() => {
        // Set to a reasonable default size
        editor.style.width = '500px';
        editor.style.height = 'auto';
      }, 100);
    }
  });
  
  // Toggle placement mode
  placementModeToggle.addEventListener('change', () => {
    isPlacementMode = placementModeToggle.checked;
    
    if (isPlacementMode) {
      showStatus('Click-to-Place mode activated. Click anywhere to place the crown.', 'success');
      // Start following cursor when mode is activated
      if (!isFollowingCursor) {
        startFollowCursor();
      }
    } else {
      showStatus('Normal drag mode activated', 'success');
      if (isFollowingCursor) {
        stopFollowCursor();
      }
    }
  });
  
  // Start following cursor
  function startFollowCursor() {
    isFollowingCursor = true;
    overlay.classList.add('follow-cursor');
    editor.style.cursor = 'crosshair';
    
    // Add mousemove event for the editor
    editor.addEventListener('mousemove', followCursor);
  }
  
  // Stop following cursor
  function stopFollowCursor() {
    isFollowingCursor = false;
    overlay.classList.remove('follow-cursor');
    editor.style.cursor = 'pointer';
    
    // Remove mousemove event
    editor.removeEventListener('mousemove', followCursor);
  }
  
  // Follow cursor function
  function followCursor(e) {
    if (isFollowingCursor) {
      const editorRect = editor.getBoundingClientRect();
      const x = e.clientX - editorRect.left - (overlay.offsetWidth / 2);
      const y = e.clientY - editorRect.top - (overlay.offsetHeight / 2);
      
      overlay.style.left = `${x}px`;
      overlay.style.top = `${y}px`;
    }
  }
  
  // Editor click handler
  editor.addEventListener('click', (e) => {
    if (isPlacementMode) {
      if (isFollowingCursor) {
        // Place the crown where clicked
        const editorRect = editor.getBoundingClientRect();
        const x = e.clientX - editorRect.left - (overlay.offsetWidth / 2);
        const y = e.clientY - editorRect.top - (overlay.offsetHeight / 2);
        
        overlay.style.left = `${x}px`;
        overlay.style.top = `${y}px`;
        
        // Stop following cursor
        stopFollowCursor();
        showStatus('Crown placed! Toggle the mode again to move it.', 'success');
      } else {
        // Start following cursor again
        startFollowCursor();
        showStatus('Crown following cursor. Click to place.', 'success');
      }
    }
  });
  
  // Drag logic with touch support
  overlay.addEventListener('mousedown', (e) => {
    if (!isPlacementMode) {
      startDrag(e);
    }
  });
  
  overlay.addEventListener('touchstart', (e) => {
    if (!isPlacementMode) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = overlay.getBoundingClientRect();
      offsetX = touch.clientX - rect.left;
      offsetY = touch.clientY - rect.top;
      isDragging = true;
    }
  });
  
  document.addEventListener('mouseup', stopDrag);
  document.addEventListener('touchend', stopDrag);
  
  document.addEventListener('mousemove', (e) => {
    if (!isPlacementMode && isDragging) {
      dragMove(e);
    }
  });
  
  document.addEventListener('touchmove', (e) => {
    if (!isPlacementMode && isDragging) {
      e.preventDefault();
      const touch = e.touches[0];
      const editorRect = editor.getBoundingClientRect();
      const x = touch.clientX - editorRect.left - offsetX;
      const y = touch.clientY - editorRect.top - offsetY;
      moveOverlay(x, y);
    }
  });
  
  function startDrag(e) {
    isDragging = true;
    const rect = overlay.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
  }
  
  function stopDrag() {
    isDragging = false;
  }
  
  function dragMove(e) {
    if (isDragging) {
      const editorRect = editor.getBoundingClientRect();
      const x = e.clientX - editorRect.left - offsetX;
      const y = e.clientY - editorRect.top - offsetY;
      moveOverlay(x, y);
    }
  }
  
  function moveOverlay(x, y) {
    // Keep within boundaries
    const editorWidth = editor.offsetWidth;
    const editorHeight = editor.offsetHeight;
    const overlayWidth = overlay.offsetWidth;
    const overlayHeight = overlay.offsetHeight;
    
    // Allow partial overflow but keep center part visible
    const minX = -overlayWidth / 2;
    const maxX = editorWidth - overlayWidth / 2;
    const minY = -overlayHeight / 2;
    const maxY = editorHeight - overlayHeight / 2;
    
    const boundedX = Math.max(minX, Math.min(maxX, x));
    const boundedY = Math.max(minY, Math.min(maxY, y));
    
    overlay.style.left = `${boundedX}px`;
    overlay.style.top = `${boundedY}px`;
  }
  
  // Upload base image
  document.getElementById('upload').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadImage(file, baseImage, () => {
      // Don't set explicit dimensions - let CSS handle the scaling
      // Instead, maintain aspect ratio while staying within viewport
      const aspectRatio = baseImage.naturalWidth / baseImage.naturalHeight;
      const maxWidth = Math.min(baseImage.naturalWidth, window.innerWidth * 0.8);
      const maxHeight = Math.min(baseImage.naturalHeight, window.innerHeight * 0.7);
      
      if (aspectRatio > 1) {
        // Wider than tall
        const width = Math.min(maxWidth, aspectRatio * maxHeight);
        editor.style.width = `${width}px`;
        editor.style.height = `${width / aspectRatio}px`;
      } else {
        // Taller than wide
        const height = Math.min(maxHeight, maxWidth / aspectRatio);
        editor.style.width = `${height * aspectRatio}px`;
        editor.style.height = `${height}px`;
      }
      
      centerOverlay();
      showStatus('Base image loaded successfully!', 'success');
    });
  });
  
  // Upload custom overlay
  document.getElementById('uploadOverlay').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    loadImage(file, overlay, () => {
      // Deselect any active overlay option
      document.querySelectorAll('.overlay-option').forEach(option => {
        option.classList.remove('active');
      });
      showStatus('Custom overlay loaded successfully!', 'success');
    });
  });
  
  // Helper function to load images
  function loadImage(file, imgElement, callback) {
    const reader = new FileReader();
    reader.onload = () => {
      imgElement.onload = callback;
      imgElement.src = reader.result;
    };
    reader.readAsDataURL(file);
  }
  
  // Transform controls with value display
  const scaleSlider = document.getElementById('scaleSlider');
  const rotateSlider = document.getElementById('rotateSlider');
  const opacitySlider = document.getElementById('opacitySlider');
  const scaleValue = document.getElementById('scaleValue');
  const rotateValue = document.getElementById('rotateValue');
  const opacityValue = document.getElementById('opacityValue');
  
  scaleSlider.addEventListener('input', updateTransform);
  rotateSlider.addEventListener('input', updateTransform);
  opacitySlider.addEventListener('input', updateTransform);
  
  function updateTransform() {
    const scale = scaleSlider.value;
    const rotate = rotateSlider.value;
    const opacity = opacitySlider.value;
    
    // Update display values
    scaleValue.textContent = `${Math.round(scale * 100)}%`;
    rotateValue.textContent = `${rotate}°`;
    opacityValue.textContent = `${Math.round(opacity * 100)}%`;
    
    // Apply transform with flipping
    let transform = `scale(${isFlippedH ? -scale : scale}, ${isFlippedV ? -scale : scale}) rotate(${rotate}deg)`;
    overlay.style.transform = transform;
    overlay.style.opacity = opacity;
  }
  
  // Overlay picker
  document.querySelectorAll('.overlay-option').forEach(option => {
    option.addEventListener('click', () => {
      document.querySelectorAll('.overlay-option').forEach(opt => {
        opt.classList.remove('active');
      });
      option.classList.add('active');
      
      // Set the selected overlay
      overlay.src = option.getAttribute('data-src');
      
      // Reset transforms when changing overlay
      isFlippedH = false;
      isFlippedV = false;
      updateTransform();
    });
  });
  
  // Reset overlay position and transform
  function resetOverlay() {
    overlay.style.left = '50px';
    overlay.style.top = '50px';
    scaleSlider.value = 1;
    rotateSlider.value = 0;
    opacitySlider.value = 1;
    isFlippedH = false;
    isFlippedV = false;
    updateTransform();
    
    // If in placement mode, start following cursor
    if (isPlacementMode && !isFollowingCursor) {
      startFollowCursor();
    }
    
    showStatus('Overlay reset to default position and settings', 'success');
  }
  
  // Center overlay
  function centerOverlay() {
    const editorWidth = editor.offsetWidth;
    const editorHeight = editor.offsetHeight;
    const overlayWidth = overlay.offsetWidth;
    const overlayHeight = overlay.offsetHeight;
    
    overlay.style.left = `${(editorWidth - overlayWidth) / 2}px`;
    overlay.style.top = `${(editorHeight - overlayHeight) / 2}px`;
    
    // If in placement mode, stop following cursor
    if (isPlacementMode && isFollowingCursor) {
      stopFollowCursor();
    }
    
    showStatus('Overlay centered', 'success');
  }
  
  // Flip horizontally
  function flipHorizontal() {
    isFlippedH = !isFlippedH;
    updateTransform();
    showStatus('Flipped horizontally', 'success');
  }
  
  // Flip vertically
  function flipVertical() {
    isFlippedV = !isFlippedV;
    updateTransform();
    showStatus('Flipped vertically', 'success');
  }
  
  // Save snapshot
  function saveImage() {
    html2canvas(editor, { 
      backgroundColor: null, 
      useCORS: true,
      scale: 2 // Higher quality
    }).then(canvas => {
      const link = document.createElement('a');
      link.download = 'edited_image.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
      showStatus('Image saved successfully!', 'success');
    }).catch(err => {
      console.error('Error saving image:', err);
      showStatus('Error saving image. Try again!', 'error');
    });
  }
  
  // Show status message
  function showStatus(message, type) {
    statusMessage.textContent = message;
    statusMessage.className = 'status-message';
    statusMessage.classList.add(type);
    
    // Reset opacity
    statusMessage.style.opacity = '1';
    
    // Hide after 3 seconds
    setTimeout(() => {
      statusMessage.style.opacity = '0';
    }, 3000);
  }
</script>
</body>
</html>
